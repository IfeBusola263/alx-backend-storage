#!/usr/bin/env python3
'''
This is a radis implemented module for caching
information.
'''
import uuid
import redis
from typing import Union, Callable
from functools import wraps


def count_calls(method: Callable) -> Callable:
    '''
    This is a decorator that will count the number of times
    any function it is decorated with is called and it will
    return the value returned by the original method.
    '''

    # the fucntools helps to retain the name of the function
    @wraps(method)
    def wrapper(self, *args, **kwargs):
        '''
        The function that does the increamenting and calls the
        original function which then returns the value
        '''
        # The qualified name dunder method will help to get the full
        # details of the method
        key = method.__qualname__

        # increment and save the counter in the redisDB
        self._redis.incrby(key)
        self._redis.save()
        result = method(self, *args, **kwargs)
        return result

    return wrapper


def call_history(method: Callable) -> Callable:
    '''
    This is a decorator that inserts the inputs of the method in a list
    and the output in another list
    '''
    @wraps(method)
    def wrapper(self, *args, **kwargs):
        '''
        This wrapper function help to push the input and output data
        into the list in the database.
        '''
        input_key = method.__qualname__ + ":inputs"
        output_key = method.__qualname__ + ":outputs"

        # push the inputs into redis and same for output after
        # executing the function
        self._redis.rpush(input_key, str(args))
        result = method(self, *args, **kwargs)
        self._redis.rpush(output_key, result)
        self._redis.save()
        return result

    return wrapper

def replay(method: Callable) -> None:
    '''
    The function displays the history calls of a particular
    function
    '''

    # @wraps(method)
    # def wrap(self, *args, **kwargs):

    # Get the key for the list as saved in the redis database
    # Use the call_history decorator above to get the understanding
    input_key = method.__qualname__ + ":inputs"
    output_key = method.__qualname__ + ":outputs"

    # Get length of the input list from the database
    totalCall = method._redis.llen(input_key)
    print(f'{method.__qualname__} was called {totalCall} times:')
    inputList = method._redis.lrange(input_key, 0, -1)
    outputList = method._redis.lrange(output_key, 0, -1)

    # The zip function will create a tuple of each item in the same
    # index of the two iterators inputList and outputList
    for args, result in zip(inputList, outputList):
        print(f'\t{method.__qualname__}(*{args.decode("utf-8")}) -> {result.decode("utf-8")}')




class Cache:
    '''
    The Cache class store an instance of a redis client
    flushes the db and implements methods to save the data.
    '''

    def __init__(self) -> None:
        '''
        This is the first method called at the instance of
        the class Cache.
        '''
        self._redis = redis.Redis()
        self._redis.flushdb()

    @call_history
    @count_calls
    def store(self, data: Union[str, bytes, int, float]) -> str:
        '''
        This method takes a data arguments and returns the key
        used to map data in the redisDB. This key is generated by
        uuid.
        '''
        uid = str(uuid.uuid4())
        self._redis.set(uid, data)
        self._redis.save()
        return uid

    def get(self, key: str, fn: Callable = None) -> Union[
            str, bytes, int, float, None]:
        '''
        This function turns the returned byte return value from redis
        to its original data type. If the key does not exists, it returns
        None.
        '''
        value = self._redis.get(key)
        if value is None:
            return None

        if callable(fn):
            value = fn(value)
            return value
        return value

    def get_str(self, key: str) -> str:
        '''
        This function parametizes the get get function with the str callable.
        '''
        return self.get(key, str)

    def get_str(self, key: str) -> int:
        '''
        This function parametizes the get function with the int callable.
        '''
        return self.get(key, int)
